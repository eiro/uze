: <<'=cut'

=head1 uze

uze is my attempt to organize my zsh environment into libraries that can be
shared and loaded when needed.

=head2 uze is just a convention

zsh can source any file from the C<$path>. so when you write 

    . mylib

zsh will find C<mylib> whereever in the C<$path>. in addition, you can setopt
C<pathdirs> to permit zsh to use commands and source files in subdirs so you
can now write

    . company/std

if there is a directory in your C<$path> that contains a subdirectory C<company>
with a C<std> in it.

as example, if C<~/bin> is in your C<$path>, you can store your functions into 
C<~/bin/company/std> then source them by typing

    . company/std

=head2 (my own) uze

my C<uze> file does some setopt that add warnings when missusing variable

    setopt warncreateglobal nounset

it also activate extended globs and brace expansions

    setopt extendedglob braceccl

then it loads some functions that i use so commonly they became first class
citizem of my scripting

=head3 shush, shush1, shush2

shush redirect all content of stderr and stdout to /dev/null so you can run
command silently.

but sometime you need something to show: shush1 remove only stdout while shush2
removes only stderr. 

=head3 warn

warn prints a message in stderr without changing the last command return (C<$?>). 

=head3 die

die warns and exit. 

=head3 fill

read multiple lines into a list of variables 

    date +"%Y\n%m" | fill year month
    echo $year

=head3 slurp

read multiple lines in an array

    getent passwd | slurp users
    print "entry of root is" $users[1]

=head3 uzu $ns $symbols[@]

asuming you have a file named C<foo/bar> or C<uze/foo/bar>
somewhere in your C<$path>

    uzu foo/bar tic tac

will 

    . foo/bar
    alias tic=foo/bar/tic
    alias tac=foo/bar/tac

Note there is nothing like the perl C<Exporter> equivalent but this would be
possible. i just have to figure out a good way to do it.


=cut

setopt warncreateglobal nounset
setopt extendedglob braceccl

# TODO: document
shush1   () { "$@" 1> /dev/null }
shush2   () { "$@" 2> /dev/null }
shush    () { "$@" &> /dev/null }
warn     () { local r=$?; print -u2 "$*"; return $r }
die      () { local r=$?; print -u2 "$*"; exit $r   }
slurp    () { IFS=$'\n' read -d '' -A $1 }
fill     () { local garbage; IFS=$'\n' read -d '' "$@" garbage }

uzu () {

    # uzu_ns   : the actual module name
    # uzu_can  : the modules found in $path
    # uzu_does : symbols of the modules to be imported

    local uzu_ns=$1 uzu_does

    typeset -a uzu_can
    uzu_can=( ${^path}/{,uze/}$1(N) )

    ((#uzu_can)) || {
        warn "can't find $uzu_ns in \$path"
        return
    }

    . $uzu_can[1]
    for uzu_does { alias $uzu_does=$uzu_ns/$uzu_does }

} 

