: <<'=cut'

=head1 uze

uze is my attempt to organize my zsh environment into libraries that can be
shared and loaded when needed.

sources for the project are available on
L<my github|https://github.com/eiro/uze>.

=head2 uze is just a convention

zsh can source any file from the C<$path>. so when you write 

    . mylib

zsh will find C<mylib> whereever in the C<$path>. in addition, you can setopt
C<pathdirs> to permit zsh to use commands and source files in subdirs so you
can now write

    . company/std

if there is a directory in your C<$path> that contains a subdirectory C<company>
with a C<std> in it.

as example, if C<~/bin> is in your C<$path>, you can store your functions into 
C<~/bin/company/std> then source them by typing

    . company/std

=head2 (my own) uze

my C<uze> file does some setopt that add warnings when missusing variable

    setopt warncreateglobal nounset

it also activate extended globs and brace expansions

    setopt extendedglob braceccl

then it loads some functions that i use so commonly they became first class
citizem of my scripting

=head3 shush, shush1, shush2

shush redirect all content of stderr and stdout to /dev/null so you can run
command silently.

but sometime you need something to show: shush1 remove only stdout while shush2
removes only stderr. 

=head3 warn

warn prints a message in stderr without changing the last command return (C<$?>). 

=head3 die

die warns and exit. 

=head3 fill

read multiple lines into a list of variables 

    date +"%Y\n%m" | fill year month
    echo $year

=head3 slurp

read multiple lines in an array

    getent passwd | slurp users
    print "entry of root is" $users[1]

=head3 uzu $ns $symbols[@]

asuming you have a file named C<foo/bar> or C<uze/foo/bar>
somewhere in your C<$path>

    uzu foo/bar tic tac

will 

    . foo/bar
    alias tic=foo/bar/tic
    alias tac=foo/bar/tac

Note there is nothing like the perl C<Exporter> equivalent but this would be
possible. i just have to figure out a good way to do it.

=head1 FATPACKING

if you don't want to deploy scripts via distribution tarballs or git
repositories, you can fatpack (this is an idea stolen
from L<App::Fatpacker|https://metacpan.org/pod/App::FatPacker>) modules in a
large self-contained files. 

Fatpacking local files using C<cat>: 

    cd path/to/my/uze
    cat uze devel/TAP openssl mir > fatpacked.zshenv

Fatpacking distant files using C<curl>:

    for lib ( uze devel/TAP openssl mir ) { 
        curl -sL https://raw.githubusercontent.com/eiro/uze/master/$lib
    } > fatpacked.zshenv

or 

    xargs -n1 curl -sL <<LIBs > fatpacked.zshenv
    https://raw.githubusercontent.com/eiro/uze/master/uze
    https://raw.githubusercontent.com/eiro/uze/master/devel/TAP
    https://raw.githubusercontent.com/eiro/uze/master/openssl
    https://raw.githubusercontent.com/eiro/uze/master/mir
    LIBs

=cut

setopt warncreateglobal nounset extendedglob braceccl pathdirs

shush1   () { "$@" 1> /dev/null }
shush2   () { "$@" 2> /dev/null }
shush    () { "$@" &> /dev/null }
warn     () { local r=$?; print -u2 "$*"; return $r }
die      () { local r=$?; print -u2 "$*"; exit $r   }
slurp    () { IFS=$'\n' read -d '' -A $1 }
fill     () { local garbage; IFS=$'\n' read -d '' "$@" garbage }

uzu/alias () {
    local uzu_al
    for uzu_al { alias $uzu_al=$uzu_ns/$uzu_al }
}

uzu () {

    local uzu_ns=$1 uzu_does
    shift
    typeset -a uzu_can
    uzu_can=( ${^path}/{,uze/}$uzu_ns(N) )

    ((#uzu_can)) || {
        warn "can't find $uzu_ns in \$path"
        return
    }

    . $uzu_can[1]
    typeset -a UZU_EXPORT
    local uzu_exporter=uzu/$uzu_ns  
    if {shush which $uzu_exporter} {
        if {$uzu_exporter $@} { uzu/alias $UZU_EXPORT }
    } else { uzu/alias $@ }
}

